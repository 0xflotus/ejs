// Dependencies
var JsonMLWalker = require('../../jsonml/grammars/jsonml_walker.ojs'),
    _            = require('../nodes'),
    join         = require('../../utils.js').join,
    escape       = require('../../utils.js').escape_string;

ometa ES5Translator <: JsonMLWalker {
                      
  // Helper rule                   
  assure_block       = ~undefined :n ( ?n.hasType('BlockStmt') walk(n)                   //     {...} -> {...}
                                     | walk(_.BlockStmt([n]))                            //       ... -> {...}
                                     ),

  // Node Translations
  Program         :n = walk*:cs                                                          -> cs.join(';\n'),

  Function        :n = walk:args walk:body ( ?n.has('id')                                -> join('function ', n.id(), '(', args.join(','), ')', body)
                                           | empty                                       -> join('function(', args.join(','), ')', body)
                                           ),
  FunctionArgs    :n = walk*:as                                                          -> as,


  // Literals
  Id              :n                                                                     -> n.value(),

  Number          :n = ?n.is('kind', 'hex')                                              -> join('0x', n.value().toString(16))
                     | ?n.is('value', parseFloat(n.original()))                          -> n.original()           // if something changed then don't 
                     | empty                                                             -> n.value().toString(),  // use the original string representation 

  String          :n                                                                     -> join('"', escape(n.value()), '"'),

   
  // Statements
  BlockStmt       :n = walk*:cs                                                          -> join('{', cs.join(';\n'), '}'),

  VarDeclStmt     :n = walk+:vs                                                          -> join(n.kind(), ' ', vs.join(',')),

  VarBinding      :n = undefined                                                         -> n.name()
                     | &anything:i ?i.hasType('Id') ?i.is('value', 'undefined') anything -> n.name()
                     | walk:init                                                         -> join(n.name(), '=', init),

  EmptyStmt       :n                                                                     -> '',
  
  IfStmt          :n = walk:c assure_block:t ( assure_block:f                            -> join('if(', c, ')', t, 'else', f)
                                             | (undefined | empty)                       -> join('if(', c, ')', t)
                                             ), 

  LabeledStmt     :n = walk:s                                                            -> join(n.label(), ': ', s),

  BreakStmt       :n                                                                     -> join('break ', n.label() !== undefined ? n.label() : ''),

  ContinueStmt    :n                                                                     -> join('continue ', n.label() !== undefined ? n.label() : ''),

  WithStmt        :n = walk:e assure_block:s                                             -> join('with(', e,')', s),

  SwitchStmt      :n = walk:e walk*:cs                                                   -> join('switch(', e, '){', cs.join(';'), '}'),

  SwitchCase      :n = ?n.is('default_case') walk*:ss                                    -> join("default: ", ss.join(';'))
                     | walk:e walk*:ss                                                   -> join('case ', e, ': ', ss.join(';')),

  ReturnStmt      :n = walk:e                                                            -> join('return ', e),

  ThrowStmt       :n = walk:e                                                            -> join('throw ', e),

  TryStmt         :n = walk:t walk:ce assure_block:c ( undefined                         -> join('try', t, 'catch(',ce,')', c)
                                                     | assure_block:f                    -> join('try', t, 'catch(',ce,')', c, 'finally', f)
                                                     )
                     | walk:t assure_block:f                                             -> join('try', t, 'finally', f),

  WhileStmt       :n = walk:ce assure_block:s                                            -> join('while(', ce, ')', s),

  DoWhileStmt     :n = assure_block:s walk:ce                                            -> join('do', s, 'while(', ce, ')'),

  ForStmt         :n = walk:ie walk:ce walk:ue assure_block:s                            -> join('for(', ie, ';', ce, ';', ue, ')', s),

  ForInStmt       :n = walk:vs walk:ce assure_block:s                                    -> join('for(', vs, ' in ', ce, ')', s),

  DebuggerStmt    :n                                                                     -> 'debugger',


  // Expressions
  ThisExpr        :n                                                                     -> 'this',

  AssignExpr      :n = walk:lhs walk:rhs                                                 -> join(lhs, n.operator(), rhs),

  CondExpr        :n = walk:ce walk:t walk:f                                             -> join(ce, '?', t, ':', f),

  UnaryExpr       :n = walk:e                                                            -> join(n.operator(), ' ', e),

  UpdateExpr      :n = walk:e ( ?n.is('prefix')                                          -> join(n.operator(), e)
                              | empty                                                    -> join(e, n.operator())
                              ),

  BinaryExpr      :n = walk:lhs walk:rhs                                                 -> join(lhs, ' ', n.operator(), ' ', rhs),

  SequenceExpr    :n = walk*:es                                                          -> es.join(','),

  NewExpr         :n = walk:cls                                                          -> join('new ', cls),

  CallExpr        :n = walk:e walk*:args                                                 -> join(e, '(', args.join(','), ')'),

  MemberExpr      :n = ?n.is('access', 'name') walk:e                                    -> join(e, '.', n.name())
                     | walk:e walk:ae                                                    -> join(e, '[', ae, ']'),

  GroupExpr       :n = walk:e                                                            -> join('(', e, ')'),
  
  ArrayExpr       :n = walk*:es                                                          -> join('[', es.join(','), ']'),

  ObjectExpr      :n = walk*:ps                                                          -> join('{', ps.join(','), '}'),

  PropertyBinding :n = ?n.is('kind', 'init') walk:id walk:e                              -> join(id, ': ', e)
                     | walk:id walk:args walk:body                                       -> join(n.kind(), ' ', id, '(', args.join(','), ')', body),

  RegExpr         :n                                                                     -> join('/', n.body(), '/', n.flags())

}
ES5Translator.force_rules = true;
ES5Translator.translate = function(input) {
  return ES5Translator.match(input, 'walk');
};

module.exports = ES5Translator
